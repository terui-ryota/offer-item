// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package entity

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// AssigneeLog is an object representing the database table.
type AssigneeLog struct {
	ID                      string    `boil:"id" json:"id" toml:"id" yaml:"id"`
	AssigneeID              string    `boil:"assignee_id" json:"assignee_id" toml:"assignee_id" yaml:"assignee_id"`
	LogType                 uint      `boil:"log_type" json:"log_type" toml:"log_type" yaml:"log_type"`
	PreviousStage           uint      `boil:"previous_stage" json:"previous_stage" toml:"previous_stage" yaml:"previous_stage"`
	PreviousStageStatus     uint      `boil:"previous_stage_status" json:"previous_stage_status" toml:"previous_stage_status" yaml:"previous_stage_status"`
	PreviousExaminationType null.Uint `boil:"previous_examination_type" json:"previous_examination_type,omitempty" toml:"previous_examination_type" yaml:"previous_examination_type,omitempty"`
	CurrentStage            uint      `boil:"current_stage" json:"current_stage" toml:"current_stage" yaml:"current_stage"`
	CurrentStageStatus      uint      `boil:"current_stage_status" json:"current_stage_status" toml:"current_stage_status" yaml:"current_stage_status"`
	CurrentExaminationType  null.Uint `boil:"current_examination_type" json:"current_examination_type,omitempty" toml:"current_examination_type" yaml:"current_examination_type,omitempty"`
	MailStage               null.Uint `boil:"mail_stage" json:"mail_stage,omitempty" toml:"mail_stage" yaml:"mail_stage,omitempty"`
	MailIsReminder          null.Bool `boil:"mail_is_reminder" json:"mail_is_reminder,omitempty" toml:"mail_is_reminder" yaml:"mail_is_reminder,omitempty"`
	Content                 string    `boil:"content" json:"content" toml:"content" yaml:"content"`
	ExecutedAt              time.Time `boil:"executed_at" json:"executed_at" toml:"executed_at" yaml:"executed_at"`
	ExecutedBy              string    `boil:"executed_by" json:"executed_by" toml:"executed_by" yaml:"executed_by"`
	CreatedAt               time.Time `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	CreatedBy               string    `boil:"created_by" json:"created_by" toml:"created_by" yaml:"created_by"`

	R *assigneeLogR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L assigneeLogL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var AssigneeLogColumns = struct {
	ID                      string
	AssigneeID              string
	LogType                 string
	PreviousStage           string
	PreviousStageStatus     string
	PreviousExaminationType string
	CurrentStage            string
	CurrentStageStatus      string
	CurrentExaminationType  string
	MailStage               string
	MailIsReminder          string
	Content                 string
	ExecutedAt              string
	ExecutedBy              string
	CreatedAt               string
	CreatedBy               string
}{
	ID:                      "id",
	AssigneeID:              "assignee_id",
	LogType:                 "log_type",
	PreviousStage:           "previous_stage",
	PreviousStageStatus:     "previous_stage_status",
	PreviousExaminationType: "previous_examination_type",
	CurrentStage:            "current_stage",
	CurrentStageStatus:      "current_stage_status",
	CurrentExaminationType:  "current_examination_type",
	MailStage:               "mail_stage",
	MailIsReminder:          "mail_is_reminder",
	Content:                 "content",
	ExecutedAt:              "executed_at",
	ExecutedBy:              "executed_by",
	CreatedAt:               "created_at",
	CreatedBy:               "created_by",
}

var AssigneeLogTableColumns = struct {
	ID                      string
	AssigneeID              string
	LogType                 string
	PreviousStage           string
	PreviousStageStatus     string
	PreviousExaminationType string
	CurrentStage            string
	CurrentStageStatus      string
	CurrentExaminationType  string
	MailStage               string
	MailIsReminder          string
	Content                 string
	ExecutedAt              string
	ExecutedBy              string
	CreatedAt               string
	CreatedBy               string
}{
	ID:                      "assignee_log.id",
	AssigneeID:              "assignee_log.assignee_id",
	LogType:                 "assignee_log.log_type",
	PreviousStage:           "assignee_log.previous_stage",
	PreviousStageStatus:     "assignee_log.previous_stage_status",
	PreviousExaminationType: "assignee_log.previous_examination_type",
	CurrentStage:            "assignee_log.current_stage",
	CurrentStageStatus:      "assignee_log.current_stage_status",
	CurrentExaminationType:  "assignee_log.current_examination_type",
	MailStage:               "assignee_log.mail_stage",
	MailIsReminder:          "assignee_log.mail_is_reminder",
	Content:                 "assignee_log.content",
	ExecutedAt:              "assignee_log.executed_at",
	ExecutedBy:              "assignee_log.executed_by",
	CreatedAt:               "assignee_log.created_at",
	CreatedBy:               "assignee_log.created_by",
}

// Generated where

type whereHelpernull_Uint struct{ field string }

func (w whereHelpernull_Uint) EQ(x null.Uint) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Uint) NEQ(x null.Uint) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Uint) LT(x null.Uint) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Uint) LTE(x null.Uint) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Uint) GT(x null.Uint) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Uint) GTE(x null.Uint) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Uint) IN(slice []uint) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Uint) NIN(slice []uint) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Uint) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Uint) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpernull_Bool struct{ field string }

func (w whereHelpernull_Bool) EQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Bool) NEQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Bool) LT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Bool) LTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Bool) GT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Bool) GTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Bool) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Bool) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var AssigneeLogWhere = struct {
	ID                      whereHelperstring
	AssigneeID              whereHelperstring
	LogType                 whereHelperuint
	PreviousStage           whereHelperuint
	PreviousStageStatus     whereHelperuint
	PreviousExaminationType whereHelpernull_Uint
	CurrentStage            whereHelperuint
	CurrentStageStatus      whereHelperuint
	CurrentExaminationType  whereHelpernull_Uint
	MailStage               whereHelpernull_Uint
	MailIsReminder          whereHelpernull_Bool
	Content                 whereHelperstring
	ExecutedAt              whereHelpertime_Time
	ExecutedBy              whereHelperstring
	CreatedAt               whereHelpertime_Time
	CreatedBy               whereHelperstring
}{
	ID:                      whereHelperstring{field: "`assignee_log`.`id`"},
	AssigneeID:              whereHelperstring{field: "`assignee_log`.`assignee_id`"},
	LogType:                 whereHelperuint{field: "`assignee_log`.`log_type`"},
	PreviousStage:           whereHelperuint{field: "`assignee_log`.`previous_stage`"},
	PreviousStageStatus:     whereHelperuint{field: "`assignee_log`.`previous_stage_status`"},
	PreviousExaminationType: whereHelpernull_Uint{field: "`assignee_log`.`previous_examination_type`"},
	CurrentStage:            whereHelperuint{field: "`assignee_log`.`current_stage`"},
	CurrentStageStatus:      whereHelperuint{field: "`assignee_log`.`current_stage_status`"},
	CurrentExaminationType:  whereHelpernull_Uint{field: "`assignee_log`.`current_examination_type`"},
	MailStage:               whereHelpernull_Uint{field: "`assignee_log`.`mail_stage`"},
	MailIsReminder:          whereHelpernull_Bool{field: "`assignee_log`.`mail_is_reminder`"},
	Content:                 whereHelperstring{field: "`assignee_log`.`content`"},
	ExecutedAt:              whereHelpertime_Time{field: "`assignee_log`.`executed_at`"},
	ExecutedBy:              whereHelperstring{field: "`assignee_log`.`executed_by`"},
	CreatedAt:               whereHelpertime_Time{field: "`assignee_log`.`created_at`"},
	CreatedBy:               whereHelperstring{field: "`assignee_log`.`created_by`"},
}

// AssigneeLogRels is where relationship names are stored.
var AssigneeLogRels = struct {
	Assignee string
}{
	Assignee: "Assignee",
}

// assigneeLogR is where relationships are stored.
type assigneeLogR struct {
	Assignee *Assignee `boil:"Assignee" json:"Assignee" toml:"Assignee" yaml:"Assignee"`
}

// NewStruct creates a new relationship struct
func (*assigneeLogR) NewStruct() *assigneeLogR {
	return &assigneeLogR{}
}

func (r *assigneeLogR) GetAssignee() *Assignee {
	if r == nil {
		return nil
	}
	return r.Assignee
}

// assigneeLogL is where Load methods for each relationship are stored.
type assigneeLogL struct{}

var (
	assigneeLogAllColumns            = []string{"id", "assignee_id", "log_type", "previous_stage", "previous_stage_status", "previous_examination_type", "current_stage", "current_stage_status", "current_examination_type", "mail_stage", "mail_is_reminder", "content", "executed_at", "executed_by", "created_at", "created_by"}
	assigneeLogColumnsWithoutDefault = []string{"id", "assignee_id", "log_type", "previous_stage", "previous_stage_status", "previous_examination_type", "current_stage", "current_stage_status", "current_examination_type", "mail_stage", "mail_is_reminder", "content", "executed_at", "executed_by", "created_at", "created_by"}
	assigneeLogColumnsWithDefault    = []string{}
	assigneeLogPrimaryKeyColumns     = []string{"id"}
	assigneeLogGeneratedColumns      = []string{}
)

type (
	// AssigneeLogSlice is an alias for a slice of pointers to AssigneeLog.
	// This should almost always be used instead of []AssigneeLog.
	AssigneeLogSlice []*AssigneeLog
	// AssigneeLogHook is the signature for custom AssigneeLog hook methods
	AssigneeLogHook func(context.Context, boil.ContextExecutor, *AssigneeLog) error

	assigneeLogQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	assigneeLogType                 = reflect.TypeOf(&AssigneeLog{})
	assigneeLogMapping              = queries.MakeStructMapping(assigneeLogType)
	assigneeLogPrimaryKeyMapping, _ = queries.BindMapping(assigneeLogType, assigneeLogMapping, assigneeLogPrimaryKeyColumns)
	assigneeLogInsertCacheMut       sync.RWMutex
	assigneeLogInsertCache          = make(map[string]insertCache)
	assigneeLogUpdateCacheMut       sync.RWMutex
	assigneeLogUpdateCache          = make(map[string]updateCache)
	assigneeLogUpsertCacheMut       sync.RWMutex
	assigneeLogUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var assigneeLogAfterSelectMu sync.Mutex
var assigneeLogAfterSelectHooks []AssigneeLogHook

var assigneeLogBeforeInsertMu sync.Mutex
var assigneeLogBeforeInsertHooks []AssigneeLogHook
var assigneeLogAfterInsertMu sync.Mutex
var assigneeLogAfterInsertHooks []AssigneeLogHook

var assigneeLogBeforeUpdateMu sync.Mutex
var assigneeLogBeforeUpdateHooks []AssigneeLogHook
var assigneeLogAfterUpdateMu sync.Mutex
var assigneeLogAfterUpdateHooks []AssigneeLogHook

var assigneeLogBeforeDeleteMu sync.Mutex
var assigneeLogBeforeDeleteHooks []AssigneeLogHook
var assigneeLogAfterDeleteMu sync.Mutex
var assigneeLogAfterDeleteHooks []AssigneeLogHook

var assigneeLogBeforeUpsertMu sync.Mutex
var assigneeLogBeforeUpsertHooks []AssigneeLogHook
var assigneeLogAfterUpsertMu sync.Mutex
var assigneeLogAfterUpsertHooks []AssigneeLogHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *AssigneeLog) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range assigneeLogAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *AssigneeLog) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range assigneeLogBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *AssigneeLog) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range assigneeLogAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *AssigneeLog) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range assigneeLogBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *AssigneeLog) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range assigneeLogAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *AssigneeLog) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range assigneeLogBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *AssigneeLog) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range assigneeLogAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *AssigneeLog) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range assigneeLogBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *AssigneeLog) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range assigneeLogAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddAssigneeLogHook registers your hook function for all future operations.
func AddAssigneeLogHook(hookPoint boil.HookPoint, assigneeLogHook AssigneeLogHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		assigneeLogAfterSelectMu.Lock()
		assigneeLogAfterSelectHooks = append(assigneeLogAfterSelectHooks, assigneeLogHook)
		assigneeLogAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		assigneeLogBeforeInsertMu.Lock()
		assigneeLogBeforeInsertHooks = append(assigneeLogBeforeInsertHooks, assigneeLogHook)
		assigneeLogBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		assigneeLogAfterInsertMu.Lock()
		assigneeLogAfterInsertHooks = append(assigneeLogAfterInsertHooks, assigneeLogHook)
		assigneeLogAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		assigneeLogBeforeUpdateMu.Lock()
		assigneeLogBeforeUpdateHooks = append(assigneeLogBeforeUpdateHooks, assigneeLogHook)
		assigneeLogBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		assigneeLogAfterUpdateMu.Lock()
		assigneeLogAfterUpdateHooks = append(assigneeLogAfterUpdateHooks, assigneeLogHook)
		assigneeLogAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		assigneeLogBeforeDeleteMu.Lock()
		assigneeLogBeforeDeleteHooks = append(assigneeLogBeforeDeleteHooks, assigneeLogHook)
		assigneeLogBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		assigneeLogAfterDeleteMu.Lock()
		assigneeLogAfterDeleteHooks = append(assigneeLogAfterDeleteHooks, assigneeLogHook)
		assigneeLogAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		assigneeLogBeforeUpsertMu.Lock()
		assigneeLogBeforeUpsertHooks = append(assigneeLogBeforeUpsertHooks, assigneeLogHook)
		assigneeLogBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		assigneeLogAfterUpsertMu.Lock()
		assigneeLogAfterUpsertHooks = append(assigneeLogAfterUpsertHooks, assigneeLogHook)
		assigneeLogAfterUpsertMu.Unlock()
	}
}

// One returns a single assigneeLog record from the query.
func (q assigneeLogQuery) One(ctx context.Context, exec boil.ContextExecutor) (*AssigneeLog, error) {
	o := &AssigneeLog{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "entity: failed to execute a one query for assignee_log")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all AssigneeLog records from the query.
func (q assigneeLogQuery) All(ctx context.Context, exec boil.ContextExecutor) (AssigneeLogSlice, error) {
	var o []*AssigneeLog

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "entity: failed to assign all query results to AssigneeLog slice")
	}

	if len(assigneeLogAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all AssigneeLog records in the query.
func (q assigneeLogQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "entity: failed to count assignee_log rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q assigneeLogQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "entity: failed to check if assignee_log exists")
	}

	return count > 0, nil
}

// Assignee pointed to by the foreign key.
func (o *AssigneeLog) Assignee(mods ...qm.QueryMod) assigneeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.AssigneeID),
	}

	queryMods = append(queryMods, mods...)

	return Assignees(queryMods...)
}

// LoadAssignee allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (assigneeLogL) LoadAssignee(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAssigneeLog interface{}, mods queries.Applicator) error {
	var slice []*AssigneeLog
	var object *AssigneeLog

	if singular {
		var ok bool
		object, ok = maybeAssigneeLog.(*AssigneeLog)
		if !ok {
			object = new(AssigneeLog)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeAssigneeLog)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeAssigneeLog))
			}
		}
	} else {
		s, ok := maybeAssigneeLog.(*[]*AssigneeLog)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeAssigneeLog)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeAssigneeLog))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &assigneeLogR{}
		}
		args[object.AssigneeID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &assigneeLogR{}
			}

			args[obj.AssigneeID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`assignee`),
		qm.WhereIn(`assignee.id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`assignee.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Assignee")
	}

	var resultSlice []*Assignee
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Assignee")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for assignee")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for assignee")
	}

	if len(assigneeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Assignee = foreign
		if foreign.R == nil {
			foreign.R = &assigneeR{}
		}
		foreign.R.AssigneeLogs = append(foreign.R.AssigneeLogs, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.AssigneeID == foreign.ID {
				local.R.Assignee = foreign
				if foreign.R == nil {
					foreign.R = &assigneeR{}
				}
				foreign.R.AssigneeLogs = append(foreign.R.AssigneeLogs, local)
				break
			}
		}
	}

	return nil
}

// SetAssignee of the assigneeLog to the related item.
// Sets o.R.Assignee to related.
// Adds o to related.R.AssigneeLogs.
func (o *AssigneeLog) SetAssignee(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Assignee) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `assignee_log` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"assignee_id"}),
		strmangle.WhereClause("`", "`", 0, assigneeLogPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.AssigneeID = related.ID
	if o.R == nil {
		o.R = &assigneeLogR{
			Assignee: related,
		}
	} else {
		o.R.Assignee = related
	}

	if related.R == nil {
		related.R = &assigneeR{
			AssigneeLogs: AssigneeLogSlice{o},
		}
	} else {
		related.R.AssigneeLogs = append(related.R.AssigneeLogs, o)
	}

	return nil
}

// AssigneeLogs retrieves all the records using an executor.
func AssigneeLogs(mods ...qm.QueryMod) assigneeLogQuery {
	mods = append(mods, qm.From("`assignee_log`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`assignee_log`.*"})
	}

	return assigneeLogQuery{q}
}

// FindAssigneeLog retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindAssigneeLog(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*AssigneeLog, error) {
	assigneeLogObj := &AssigneeLog{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `assignee_log` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, assigneeLogObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "entity: unable to select from assignee_log")
	}

	if err = assigneeLogObj.doAfterSelectHooks(ctx, exec); err != nil {
		return assigneeLogObj, err
	}

	return assigneeLogObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *AssigneeLog) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("entity: no assignee_log provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(assigneeLogColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	assigneeLogInsertCacheMut.RLock()
	cache, cached := assigneeLogInsertCache[key]
	assigneeLogInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			assigneeLogAllColumns,
			assigneeLogColumnsWithDefault,
			assigneeLogColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(assigneeLogType, assigneeLogMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(assigneeLogType, assigneeLogMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `assignee_log` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `assignee_log` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `assignee_log` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, assigneeLogPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "entity: unable to insert into assignee_log")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "entity: unable to populate default values for assignee_log")
	}

CacheNoHooks:
	if !cached {
		assigneeLogInsertCacheMut.Lock()
		assigneeLogInsertCache[key] = cache
		assigneeLogInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the AssigneeLog.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *AssigneeLog) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	assigneeLogUpdateCacheMut.RLock()
	cache, cached := assigneeLogUpdateCache[key]
	assigneeLogUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			assigneeLogAllColumns,
			assigneeLogPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("entity: unable to update assignee_log, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `assignee_log` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, assigneeLogPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(assigneeLogType, assigneeLogMapping, append(wl, assigneeLogPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "entity: unable to update assignee_log row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "entity: failed to get rows affected by update for assignee_log")
	}

	if !cached {
		assigneeLogUpdateCacheMut.Lock()
		assigneeLogUpdateCache[key] = cache
		assigneeLogUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q assigneeLogQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "entity: unable to update all for assignee_log")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "entity: unable to retrieve rows affected for assignee_log")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o AssigneeLogSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("entity: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), assigneeLogPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `assignee_log` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, assigneeLogPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "entity: unable to update all in assigneeLog slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "entity: unable to retrieve rows affected all in update all assigneeLog")
	}
	return rowsAff, nil
}

var mySQLAssigneeLogUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *AssigneeLog) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("entity: no assignee_log provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(assigneeLogColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLAssigneeLogUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	assigneeLogUpsertCacheMut.RLock()
	cache, cached := assigneeLogUpsertCache[key]
	assigneeLogUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			assigneeLogAllColumns,
			assigneeLogColumnsWithDefault,
			assigneeLogColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			assigneeLogAllColumns,
			assigneeLogPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("entity: unable to upsert assignee_log, could not build update column list")
		}

		ret := strmangle.SetComplement(assigneeLogAllColumns, strmangle.SetIntersect(insert, update))

		cache.query = buildUpsertQueryMySQL(dialect, "`assignee_log`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `assignee_log` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(assigneeLogType, assigneeLogMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(assigneeLogType, assigneeLogMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "entity: unable to upsert for assignee_log")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(assigneeLogType, assigneeLogMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "entity: unable to retrieve unique values for assignee_log")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "entity: unable to populate default values for assignee_log")
	}

CacheNoHooks:
	if !cached {
		assigneeLogUpsertCacheMut.Lock()
		assigneeLogUpsertCache[key] = cache
		assigneeLogUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single AssigneeLog record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *AssigneeLog) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("entity: no AssigneeLog provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), assigneeLogPrimaryKeyMapping)
	sql := "DELETE FROM `assignee_log` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "entity: unable to delete from assignee_log")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "entity: failed to get rows affected by delete for assignee_log")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q assigneeLogQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("entity: no assigneeLogQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "entity: unable to delete all from assignee_log")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "entity: failed to get rows affected by deleteall for assignee_log")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o AssigneeLogSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(assigneeLogBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), assigneeLogPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `assignee_log` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, assigneeLogPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "entity: unable to delete all from assigneeLog slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "entity: failed to get rows affected by deleteall for assignee_log")
	}

	if len(assigneeLogAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *AssigneeLog) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindAssigneeLog(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *AssigneeLogSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := AssigneeLogSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), assigneeLogPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `assignee_log`.* FROM `assignee_log` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, assigneeLogPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "entity: unable to reload all in AssigneeLogSlice")
	}

	*o = slice

	return nil
}

// AssigneeLogExists checks if the AssigneeLog row exists.
func AssigneeLogExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `assignee_log` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "entity: unable to check if assignee_log exists")
	}

	return exists, nil
}

// Exists checks if the AssigneeLog row exists.
func (o *AssigneeLog) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return AssigneeLogExists(ctx, exec, o.ID)
}
